<div class="noshow">
<%= form_with(model: shader, local: true) do |form| %>
  <% if shader.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(shader.errors.count, "error") %> prohibited this shader from being saved:</h2>

      <ul>
      <% shader.errors.full_messages.each do |message| %>
        <li><%= message %></li>
      <% end %>
      </ul>
    </div>
  <% end %>

  <div class="field">
    <%= form.label :user_id %>
    <%= form.text_field :user_id %>
  </div>

  <div class="field">
    <%= form.label :fbx_text %>
    <%= form.text_area :fbx_text %>
  </div>

  <div class="field">
    <%= form.label :vertex_text %>
    <%= form.text_area :vertex_text %>
  </div>

  <div class="field">
    <%= form.label :fragment_text %>
    <%= form.text_area :fragment_text %>
  </div>

  <div class="field">
    <%= form.label :dat_gui_text %>
    <%= form.text_area :dat_gui_text %>
  </div>

  <div class="field">
    <%= form.label :img_url %>
    <%= form.text_field :img_url %>
  </div>

  <div class="actions">
    <%= form.submit %>
  </div>
<% end %>
</div>

<div style="width:60%; height:800px; float:left;">

	<div style="width:100%; height:30px; border-bottom:1px solid lightgrey;">
                <button id="btn-scene" class="btn btn-default btn btn-icon-text ember-view active" onclick="shaders.select_tab(this)">
                        <span class="d-button-label">Scene</span>
                </button>
                <button id="btn-code" class="btn btn-default btn btn-icon-text ember-view" onclick="shaders.select_tab(this)">
                        <span class="d-button-label">Code</span>
                </button>
		<button id="btn-compile" class="btn btn-default btn btn-icon-text ember-view" style="width:150px; float:right;">
                       	<span class="d-button-label">Compile</span>
                </button>
	</div>
	<div id="tab-scene" class="tab-view" style="width:100%; height:500px; border:1px solid lightgrey; display:block;">
		<div id="btnbox-in-code" style="width:100%; height:30px; border-bottom:1px solid lightgrey;">			
                	<button id="btn-fbx" class="btn btn-default btn btn-icon-text ember-view" style="width:150px;">
				<i class="fa fa-plus d-icon d-icon-plus"></i>
        	                <span class="d-button-label">FBX</span>
	                </button>			
		</div>
		<!--<img src="/images/K-249.png" style="width:100%; height:465px;"></img>-->
		<div id="scene-view" style="width:100%; height:465px;"></div>		
	</div>
	<div id="tab-code" class="tab-view"style="width:100%; min-height:450px; height:auto; display:none;">
		<div id="btnbox-in-code" style="width:100%; height:30px; border-bottom:1px solid lightgrey;">			
                	<button id="btn-vertex" class="btn btn-default btn btn-icon-text ember-view active" style="width:150px;" onclick="TabVertex(true)" value='VERTEX'>
				<i class="fa fa-plus d-icon d-icon-plus"></i>
        	                <span class="d-button-label">vertex</span>
	                </button>			
			<button id="btn-fragment" class="btn btn-default btn btn-icon-text ember-view" style="width:150px;" onclick="TabFrag(true)" value='FRAGMENT'>
				<i class="fa fa-plus d-icon d-icon-plus"></i>
                        	<span class="d-button-label">fragment</span>
                	</button>
		</div>
		<div id="code-view" class="tab-view-sub" style="width:100%; height:450px; overflow:auto; padding: 10px; box-sizing: border-box;"></div>		
		<div id="shader-error" style="width:100%; padding:10px 5px; border:1px solid lightgrey; text-align:center; box-sizing:border-box;">
			<b style="color:red">쉐이더 에러시 에러 출력 부분</b>
		</div>
	</div>
	<div class="write-form" style="width:100%; height:auto;">
		<table class="write-table"  cellpadding="15" cellspacing="5px">
			<tr>
				<td>제목</td>
				<td>
					<input tyle="text" value="" placeholder="제목을 작성 해 주세요" style="padding:5px 10px; width:100%; box-sizing:border-box;"></input>
				</td>
			</tr>
			<tr>
				<td>설명</td>
				<td>
					<textarea style="width:100%; height:100px; padding: 10px; margin:0; box-sizing:border-box; resize:none; border:0;" placeholder="짧은 쉐이더 소개글 솰라솰라"></textarea>
				</td>
			</tr>
			<tr>
				<td>Screenshot</td>
				<td>
					<button id="btn-fragment" class="btn btn-default btn btn-icon-text ember-view" style="width:100%;">
        	        	        	<span class="d-button-label">Upload</span>
	                		</button>
					
				</td>
			</tr>

		</table>
		<div class="submit-form" style="width:100%; height:30px;">
			<button id="btn-fragment" class="btn btn-default btn btn-icon-text ember-view" style="width:150px; float:right; margin-right:7px;">
                        	<span class="d-button-label">Submit</span>
                	</button>
			<div id="compile_message" style="display:inline-block; height:100%; float:right; padding:5px 20px; 0 0; color:red;">
				*변경점이 있습니다 컴파일을 해주세요
			</div>
		</div>

	</div>
</div>
<div style="width:35%; height:760px; float:left; padding: 30px 10px 10px 10px;">	
	<div id="dat-view"style="width:100%; height:auto; float:right; background-color:black; color:white;">
		<!--<img src="/images/K-250.png" style="width:100%; height:100%;"></img>-->
	</div>
</div>










		<div id="shader_div" style="border 5px solid red;">
		<div>
			
		<div id="editor" style="position: absolute; top: 620px;">
		<p id="code_vert_error"></p>
		<p id="code_frag_error"></p>

		<input id="fbxFile" type="file" accept=".fbx">
		<input id="vertexFile" type="file" accept="text/*">
		<input id="fragFile" type="file" accept="text/*">
		<input id="textureFile0" type="file" accept=".jpg">
		<input id="textureFile1" type="file" accept=".jpg">
		<input id="textureFile2" type="file" accept=".jpg">
		<input id="textureFile3" type="file" accept=".jpg">
		<input id="textureFile4" type="file" accept=".jpg">
		<input id="textureFile5" type="file" accept=".jpg">
		<input id="textureFile6" type="file" accept=".jpg">
		<input id="textureFile7" type="file" accept=".jpg">
		<input id="textureFile8" type="file" accept=".jpg">
		<input id="textureFile9" type="file" accept=".jpg">
		<input id="textureFile10" type="file" accept=".jpg">
		<input id="textureFile11" type="file" accept=".jpg">
		<input id="textureFile12" type="file" accept=".jpg">
		<input id="textureFile13" type="file" accept=".jpg">
		<input id="textureFile14" type="file" accept=".jpg">
		<input id="textureFile15" type="file" accept=".jpg">
		<input id="textureFile16" type="file" accept=".jpg">
		<input id="textureFile17" type="file" accept=".jpg">
		<input id="textureFile18" type="file" accept=".jpg">
		<input id="textureFile19" type="file" accept=".jpg">
		<input id="textureFile20" type="file" accept=".jpg">

		<!-- Texture LOAD>> <input id="uvFile" type="file" accept=".jpg"> -->
		<!--<input type="button" value='VERTEX' onclick="TabVertex(true)"> <input type="button" value='FRAGMENT' onclick="TabFrag(true)">-->
 		</div>


		<script id="vertex_shh" type="x-shader/x-vertex">		
		precision mediump float;

		varying highp vec2 xlv_TEXCOORD0;
		void main ()
		{
		  highp vec4 tmpvar_1;
		  highp vec4 tmpvar_2;
		  highp vec4 tmpvar_3;
		  tmpvar_3.w = 1.0;
		  tmpvar_3.xyz = position.xyz;
		  tmpvar_2 = (projectionMatrix * (modelViewMatrix * tmpvar_3));
		  highp vec4 o_4;
		  highp vec4 tmpvar_5;
		  tmpvar_5 = (tmpvar_2 * 0.5);
		  highp vec2 tmpvar_6;
		  tmpvar_6.x = tmpvar_5.x;
		  tmpvar_6.y = tmpvar_5.y;//(tmpvar_5.y * projection.x);
		  o_4.xy = (tmpvar_6 + tmpvar_5.w);
		  o_4.zw = tmpvar_2.zw;
		  tmpvar_1.xy = o_4.xy;
		  xlv_TEXCOORD0 = uv.xy;
		  gl_Position = tmpvar_2;
		}
		</script>	

		<script id="fragment_shh" type="x-shader/x-fragment">
		precision mediump float;

		uniform float temp;
		uniform vec2 _vec2Color;
		uniform vec4 _time;

		varying highp vec2 xlv_TEXCOORD0;
		void main ()
		{
		  lowp float s_1;
		  lowp vec2 p_2;
		  highp vec2 tmpvar_3;
		  tmpvar_3 = ((2.0 * xlv_TEXCOORD0) - 1.0);
		  p_2 = tmpvar_3;
		  lowp vec3 tmpvar_4;
		  tmpvar_4.xy = vec2(1.0, 0.8);
		  tmpvar_4.z = (0.7 - (0.07 * p_2.y));
		  lowp vec3 tmpvar_5;
		  tmpvar_5 = (tmpvar_4 * (1.0 - (0.25 * 
		    sqrt(dot (p_2, p_2))
		  )));
		  highp float tmpvar_6;
		  tmpvar_6 =(_time.y / 1.5);// 0.0;//
		  highp float tmpvar_7;
		  tmpvar_7 = (fract(abs(tmpvar_6)) * 1.5);
		  highp float tmpvar_8;
		  if ((tmpvar_6 >= 0.0)) {
		    tmpvar_8 = tmpvar_7;
		  } else {
		    tmpvar_8 = -tmpvar_7;
		  }
		  lowp float tmpvar_9;
		  tmpvar_9 = (tmpvar_8 / 1.5);
		  p_2 = (p_2 * (vec2(0.5, 1.5) + (
		    (1.0 + (((
		      ((pow (tmpvar_9, 0.2) * 0.5) + 0.5)
		     * 0.5) * sin(
		      ((18.8493 * tmpvar_9) + (p_2.y * 0.5))
		    )) * exp((
		      -tmpvar_9)
		     * 4.0))))
		   * vec2(0.5, -0.5)));
		  p_2 = (p_2 * 0.8);
		  p_2.y = ((-0.1 - (p_2.y * 1.2)) + (abs(p_2.x) * (1.0 - 
		    abs(p_2.x)
		  )));
		  lowp float tmpvar_10;
		  tmpvar_10 = sqrt(dot (p_2, p_2));
		  s_1 = ((0.75 + (0.75 * p_2.x)) * (1.0 - (0.4 * tmpvar_10)));
		  s_1 = (0.3 + (0.7 * s_1));
		  s_1 = (s_1 * (0.5 + (0.5 * 
		    pow ((1.0 - clamp ((tmpvar_10 / 0.5), 0.0, 1.0)), 0.1)
		  )));
		  lowp vec3 tmpvar_11;
		  tmpvar_11.xz = vec2(_vec2Color.x, _vec2Color.y);//vec2(1.0, 0.3);
		  tmpvar_11.y = (0.5 * tmpvar_10);
		  lowp float tmpvar_12;
		  tmpvar_12 = clamp (((
		    (0.5 - tmpvar_10)
		   - -0.01) / 0.02), 0.0, 1.0);
		  lowp vec4 tmpvar_13;
		  tmpvar_13.w = 1.0;
		  tmpvar_13.xyz = mix (tmpvar_5, (tmpvar_11 * s_1), vec3((tmpvar_12 * (tmpvar_12 * 
		    (3.0 - (2.0 * tmpvar_12))
		  ))));
		  gl_FragColor = tmpvar_13;
		}

		</script>			

		<!-- Javascript code that runs our Three.js examples -->
		<script>
			var sceneWidth = $('#scene-view').width();
			var sceneHeight = $('#scene-view').height();

			//렌더러 초기화 전에 추가 : http://gupuru.hatenablog.jp/entry/2014/01/05/224813
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var _Container, _Stats, _Controls;
			var _Camera, _Scene, _Render, _Light;
			var _Material;
			var _CodeEditor;
			var clock = new THREE.Clock();	
		 	var _ObjectBox;		
	 	 	var _Object;
	 	 	var _VertexShaderSource, _FragmentShaderSource, BackupVertexShader, BackupFragShader = "";

	 	 	//var _uvTexutre;
	 	 	var isVertexTab, isFragTab = false;
	 	 	var qualifiers = [];

	 	 	var guiInfo = { fbx:"empty", vertexShader:"empty", fragmentShader:"empty"};
	 	 	var backupGuiUnfo = { fbx:"empty", vertexShader:"empty", fragmentShader:"empty"};
			var datInfo;
			var _GUI = new dat.GUI( { width: $('#dat-view').width() } )

		  	var fileTagNames= [];
		  	var fileTagBackup = [];
		  	var currentSelectTexture = '';

		  	var fileIndex = 0;	

		  	var jsonData, basicData;	

			Init();
			Animate();		


			//vertex, fragment Shader를 불러와서 tokenize후 qualifiers를 셋팅한다. - shader내용이 바뀔때마다 불려야한다.
			function setQualifiers(vertexShaderSource, fragmentShaderSource)
			{
				var tokenController = new Tokenization();		    	
		    	console.log("tokenController : " + tokenController);

		    	var vertex = tokenController.tokenize(vertexShaderSource);
		    	var frag = tokenController.tokenize(fragmentShaderSource);

		    	var tokens = vertex.concat(frag);
		    	console.log("tokens : " + tokens.length);
		    	if(typeof tokens != 'undefined')
		    	{
		    		//for(var i = 0; i < tokens.length; ++i)
		    		//	console.log("i (data) : " + tokens[i].data + "(" + tokens[i].type + ")");

		    		qualifiers = getQualifierTokenize(tokens);
		    		//console.log("------------------------------------------------------------qualifiers : " + qualifiers.length);

		    		/*var qualifierStr = "";
		    		for(var i = 0; i < qualifiers.length; ++i)
		    		{
		    			qualifierStr = qualifiers[i].qualifier;
	    				qualifierStr += " " + qualifiers[i].keyword;
		    			qualifierStr += " " + qualifiers[i].variableName;
		    			console.log("i : " + qualifierStr);
		    		}*/
		    	}  	
			}			   

			//ShaderSource에서 Uniform을 꺼내서 셋팅하여 배열로 리턴한다.
		    function getQualifierTokenize(tokens) 
			{
				var arry = [];
				
				var temp_qualifier = ''; //한정자
				var temp_keyword = ''; //변수 타입
				var temp_variableName = ''; //변수 이름

				var isQualifier = false;
				for(var i = 0; i < tokens.length; ++i) {
					if(isQualifier == false) {
						if(tokens[i].data == "uniform" && tokens[i].type == "keyword")
					  	{
					  		isQualifier = true;
					  		temp_qualifier = tokens[i].data; 
					  	}
					}
					else {
						switch(tokens[i].type) {
							case "keyword":								
								temp_keyword = tokens[i].data;
								break;
							case "ident":
								temp_variableName = tokens[i].data;
								break;
							case "operator":
								if(tokens[i].data == ";") {
									isQualifier = false;
									arry.push({
										qualifier : temp_qualifier,
										keyword : temp_keyword,
										variableName : temp_variableName,
									});

									temp_qualifier = '';
									temp_keyword = '';
									temp_variableName = '';
								}
								break;
						}
					}
				}
			  return arry;
			}

			/*function getQualifiers()
		    {		    	
		    	var temp = [];
		    	for(var i = 0; i < qualifiers.length; ++i)
		    	{
		    		temp.push({
		    			key: qualifiers[i].variableName, 
		    			type: qualifiers[i].temp_keyword,
		    		});
		    	}
		    	return temp;
		    }*/

		  	function InitGUI()
		  	{		  		

		  		datInfo = function() {

					//this.objectName = guiInfo['object'];
					//this.uv = guiInfo['texture'];

					//this.vertexShader = guiInfo['vertexShaderName'];
					//this.fragmentShader = guiInfo['fragmentShaderName'];

					this.ShaderCompile = function() { 
					  	onCompile();
					};

					this.Save = function(){
						SetJsonData();
					};

					this.Load = function() {
						GetJsonData();
					};

					this.ALLReset = function(){
						console.log('ALLReset');
						Reset();
						
						//SetGUIFolderValue('positionX', 0);						
					};
					//this.tempFunc = fbxFunc;
				  // Define render logic ...
				};	

				var info = new datInfo();

				GUISetting(info);	
		  	}

		  	function Reset()
		  	{
		  		RemoveSceneObject();
				_Object = undefined;					

				guiInfo = { fbx:"empty", vertexShader:"empty", fragmentShader:"empty"};

				//Codemirror 관련
				_VertexShaderSource = "";
				_FragmentShaderSource = "";
				_CodeEditor.setValue(_VertexShaderSource);
				//tokenizer 관련
				qualifiers = [];
				//Texture 관련
				//fileTagNames = [];
				//fileTagBackup = [];
				fileIndex = 0;
				//Dat.GUI
				ResetDatGUI();
		  	}	  

		  	let outParams;	

		  	function fbxFunc() { FileCallback('fbxFile', onAddFBX); }
		  	function vertexFunc() { FileCallback('vertexFile', onAddVertexShader); }
		  	function fragFunc() { FileCallback('fragFile', onAddFragShader); }

		  	function FileCallback(id, func)
		  	{
		  		document.getElementById(id).click();
			 	document.getElementById(id).onchange = func;		  		
		  	}

		  	var FBXArrayBuffer;

		  	function onAddFBX(file)
			{				
				console.log('onAddFBX!!!!!!!!!!!');
				var filename = file.target.files[0].name;		

				//guiInfo['object'] = filename;
				guiInfo['fbx'] = filename;

				var reader = new FileReader();
				reader.addEventListener( 'load', function ( event ) {

					_GUI.updateDisplay();
					//_GUI.updateDisplayCustom(filename);

					FBXArrayBuffer = event.target.result;								
					CreateFBXObject(FBXArrayBuffer);					

				}, false );
				reader.readAsArrayBuffer( file.target.files[0] );
				file.target.value = '';
			}		  	

			function CreateFBXObject(arrayBuffer)
			{
				var loader = new THREE.FBXLoader();
				var object = loader.parse( arrayBuffer );					

				object.traverse( function ( child ) {					
				} );
				AddSceneObject(object);
			}
        	
		    function GUISetting(info)
			{			
				//_GUI.remember(guiInfo);
				_GUI.addCustom(guiInfo, 'fbx', fbxFunc);

				_GUI.addCustom(guiInfo, 'vertexShader', vertexFunc);
				_GUI.addCustom(guiInfo, 'fragmentShader', fragFunc);
				
		        _GUI.add(info, 'ShaderCompile');
		        _GUI.add(info, 'Save');
		        _GUI.add(info, 'Load');
		        _GUI.add(info, 'ALLReset');		        
			}			

			//qualifiers을 바탕으로 Dat.GUI에 변수들을 타입에 맞게 Floader를 초기화하고 add해준다.
			function generateUI()//, shader)
		    {
			  	var paramsStruct = []; //qualifiers의 정보들로   
				for(var i = 0; i < qualifiers.length; ++i)
				{			  	
			  		//console.log("key : " + qualifiers[i].variableName + " / type : " + qualifiers[i].keyword);
			  		if (qualifiers[i].keyword === 'float') //float
			  		{
					    paramsStruct.push({ [qualifiers[i].variableName]: 1 });
					}
					else if (qualifiers[i].keyword.startsWith('vec')) { //vec2~4
					   paramsStruct.push([
					    { [`${qualifiers[i].variableName}.x`]: 0 },
					    { [`${qualifiers[i].variableName}.y`]: 0 },
					    { [`${qualifiers[i].variableName}.z`]: 0 },
					    { [`${qualifiers[i].variableName}.w`]: 1 }
					  ].slice(0, parseInt(qualifiers[i].keyword.replace('vec', '')))
					  );
					}
					else if(qualifiers[i].keyword.startsWith('sampler2D'))
					{
						paramsStruct.push({ [qualifiers[i].variableName]: 'undefined' });
					}
					else if(qualifiers[i].keyword.startsWith('samplerCube'))
					{
						 paramsStruct.push([
					    { [`${qualifiers[i].variableName}[0]`]: 'undefined' },
					    { [`${qualifiers[i].variableName}[1]`]: 'undefined' },
					    { [`${qualifiers[i].variableName}[2]`]: 'undefined' },
					    { [`${qualifiers[i].variableName}[3]`]: 'undefined' },
					    { [`${qualifiers[i].variableName}[4]`]: 'undefined' },
					    { [`${qualifiers[i].variableName}[5]`]: 'undefined' },
					    ]);
					}
			 	}
				// output params
				var _flattenArray = flattenDeep(paramsStruct);
				outParams = _flattenArray.reduce((memo, value) => Object.assign(memo, value), {});
				
			    paramsStruct.forEach((params, i) => 
			    {
			    	var folder = _GUI.addFolder(qualifiers[i].variableName); //변수명으로 폴더 생성.
			    	if(typeof params.length == 'undefined')	//단일 변수
			    	{
			    		if(qualifiers[i].keyword.startsWith('sampler2D')) {
			    			setTextureArray(params, folder, false);
			    		}		    	
			    		else {	    			
			    			folder.addCustom(outParams, Object.keys(params)[0]).onChange( updateUniform );			    			
			    		}		    		
			    	}
			    	else //
			    	{	
			    		if(qualifiers[i].keyword.startsWith('samplerCube'))
			    		{
			    			params.forEach(params =>  {
			    				setTextureArray(params, folder, true);
			    			});
			    		}
			    		else
			    		{
			    			params.forEach(params =>  {
						      folder.add(outParams, Object.keys(params)[0]).onChange( updateUniform );
						    });	
			    		}		    						    
			    	}
				   	folder.open();			   
			  	});			  		 
			  	return outParams;
			}

			function setTextureArray(params, folder, isCube)
			{
				var id;
    			var _key = Object.keys(params)[0];

    			if(fileTagNames[_key] == undefined) {
    				id = "textureFile" + fileIndex;
    				fileIndex++;
    				var _tempTag = {[`${_key}`]: 'empty'};
    				var _tempData = {[`${_key}`]: {id:id, texture:'undefined'}};
    				Object.assign(fileTagNames, _tempTag); //fileTagNames로 tempTag를 복사.
    				Object.assign(fileTagBackup, _tempData);
				}
				else {
					id = fileTagNames[_key];
				}
				
				folder.add(fileTagNames, _key, function(){
    				currentSelectTexture = _key;
    				FileCallback(fileTagBackup[currentSelectTexture]['id'], onAddTexture)
				});		  			
			}
			
		  	function onAddTexture(file)
			{
				console.log('onAddTexture!!!!!!!!!!!');
				var filename = file.target.files[0].name;
				console.log('currentSelectTexture ' + currentSelectTexture);
				fileTagNames[currentSelectTexture] = filename;
				
				var image = new Image();
				var reader = new FileReader();
				reader.addEventListener( 'load', function ( event ) {
					_GUI.updateDisplay();
					image.src = event.target.result;
					fileTagBackup[currentSelectTexture]['texture'] = image;		
				}, false );
				reader.readAsDataURL( file.target.files[0] );
				//file.target.value = '';
			}	

			//dat.GUI 로 변경되는 내용을 materail에 실시간으로 갱신시켜준다. 
			function updateUniform()
			{							
				_Material.uniforms.needsUpdate = true;
				
				for(var i = 0; i < qualifiers.length; ++i)
				{
					var _folderKey = qualifiers[i].variableName;			        
			        if(qualifiers[i].keyword == 'sampler2D') 
			        {
			        	//var _key = _GUI.__folders[key].__controllers[0].property;
			        	//console.log('sampler2D : ' + _key);
			        	//_GUI.__folders[key].__controllers[0].object[_key];
			        }
			        else//vec값의 경우 dat.GUI 값이 변하면 실시간으로 수정하여 준다.
			        {
			        	_Material.uniforms[_folderKey].value = GetGUIValue(_folderKey);			        	
			        }
				}

				_Object.traverse(function(child){
		    		if(child instanceof THREE.Mesh)
		    		{
		    			child.material.needsUpdate = true;
		    			child.material = _Material;
		    		}
		    	});
			}

			
			//--------------------------------------------------------------------------------------------- ** SaveJson

			function SetJsonData()
			{
				Object.keys(_GUI.__folders).forEach(function(object, index){
					//console.log("key : " + object);
					GetCurrentGUIValue(object, _GUI.__folders[object].__controllers);
				});

				jsonData = JSON.stringify(qualifiers);
				console.log("_json : " + jsonData);

				backupGuiUnfo = guiInfo;

				BackupVertexShader = _VertexShaderSource;
				BackupFragShader = _FragmentShaderSource;
			}	

			function GetCurrentGUIValue(folderKey, array)
			{
				
				var _qual = qualifiers.find(function(element){
					return element.variableName == folderKey;
				});

				//console.log("variableName : " + _qual.variableName + " / keyword : " + _qual.keyword);
				if(_qual.keyword == 'sampler2D')
				{	
					var _key = array[0].property;
					var _tempValue = array[0].object[_key];					
					_qual["value"] = GetTexture(_tempValue);
				}
				else if(_qual.keyword == 'samplerCube')
				{

				}
				else
				{					
					_qual["value"] = GetGUIValue(folderKey);
				}
				console.log("folderKey : " + folderKey + " / keyword : " + _qual.keyword + " / value : " + _qual["value"]);		
			}

			//--------------------------------------------------------------------------------------------- ** Load Json

			function GetJsonData()
			{
				guiInfo = backupGuiUnfo;

				_VertexShaderSource = BackupVertexShader;
				_FragmentShaderSource = BackupFragShader;

				var _parseBasic = FBXArrayBuffer;//JSON.parse(basicData);
				CreateFBXObject(_parseBasic);

				ReSetting(_VertexShaderSource, _FragmentShaderSource);


				qualifiers = JSON.parse(jsonData);
				SetDatGuiData();
				updateUniform();

				_GUI.updateDisplay();
			}

			function SetDatGuiData()
			{
				for(var i = 0; i < qualifiers.length; ++i)
				{
					var _folderKey = qualifiers[i].variableName;	
					if(typeof qualifiers[i].value != 'undefined')					
					{
						if(qualifiers[i].keyword == 'sampler2D') 
				        {
				        	var _key = _GUI.__folders[_folderKey].__controllers[0].property;
				        	var _texture =  GetTexture(fileTagBackup[_key]['texture']);
				        	if(typeof _texture != 'undefined') {
				        		if(_Material.uniforms[_folderKey].value != _texture) {
				        			_Material.uniforms[_folderKey].value = _texture;			        			
				        		}
				        	}			        	
				        }
				        else//vec값의 경우 dat.GUI 값이 변하면 실시간으로 수정하여 준다.
				        {
				        	var _value = GetQualifiersValues(i);
				        	if(typeof _value != 'undefined' && _value.length > 0)
					        	SetGUIValue(_folderKey, _value);
					        
				        }
					}			        
				}
			}

			function GetQualifiersValues (index)
			{
				var _values = [];
				Object.keys(qualifiers[index].value).forEach(function(key){
					_values.push(qualifiers[index].value[key]);
				});
				return _values;
			}

			function GetGUIValue(folderKey)
			{
				var _keys = GetGUIControllersKeys(folderKey);				

				var _value;
				switch(_GUI.__folders[folderKey].__controllers.length)
				{
					case 1:
					_value = _GUI.__folders[folderKey].__controllers[0].object[_keys[0]];
					break;
					case 2:
					_value = new THREE.Vector2( 					
		        	 	_GUI.__folders[folderKey].__controllers[0].object[_keys[0]], 
		        	 	_GUI.__folders[folderKey].__controllers[1].object[_keys[1]]	        	 	
		        	 	);	
					break;
					case 3:
					_value = new THREE.Vector3( 					
		        	 	_GUI.__folders[folderKey].__controllers[0].object[_keys[0]], 
		        	 	_GUI.__folders[folderKey].__controllers[1].object[_keys[1]],
		        	 	_GUI.__folders[folderKey].__controllers[2].object[_keys[2]]		        	 	
		        	 	);	
					break;
					case 4:
					_value = new THREE.Vector4( 					
		        	 	_GUI.__folders[folderKey].__controllers[0].object[_keys[0]], 
		        	 	_GUI.__folders[folderKey].__controllers[1].object[_keys[1]],
		        	 	_GUI.__folders[folderKey].__controllers[2].object[_keys[2]],
		        	 	_GUI.__folders[folderKey].__controllers[3].object[_keys[3]] 
		        	 	);		
					break;
				}
				return _value;	
			}

			function SetGUIValue(folderKey, values)
			{
				var _keys = GetGUIControllersKeys(folderKey);
				
				_SetGUIVec(folderKey, _keys, values);
			}

			function _SetGUIVec(folderKey, keys, values)
			{
				var _count = _GUI.__folders[folderKey].__controllers.length;
				for(var i = 0; i < _count; ++i)
				{
					_GUI.__folders[folderKey].__controllers[i].object[keys[i]] = values[i];
				}
			}

			function GetGUIControllersKeys(folderKey)
			{
				var _keys = [];
				var _count = _GUI.__folders[folderKey].__controllers.length;
				for(var i = 0; i < _count; ++i)
					_keys[i] = _GUI.__folders[folderKey].__controllers[i].property;
				return _keys;
			}


			//qualifiers에 있는 uniform변수들의 값을 초기화해서 내보낸다.
			function getUniforms()
		    {
		    	var uniforms = [];
				for(var i = 0; i < qualifiers.length; ++i) {
					uniforms.push(
				  		{ [`${qualifiers[i].variableName}`]: {  value: getTypeValue(qualifiers[i].keyword)}},
				  		);
				}

				uniforms = flattenDeep(uniforms);
				let objectList = uniforms.reduce((memo, value) => Object.assign(memo, value), {});
				return objectList;
		    }
		  
		  	//해당 타입별로 초기화값을 불러낸다.
		    function getTypeValue(type)
		    {
		    	var value;
		    	switch(type)
		    	{
		    		case 'float': value = 0.1; break;
		    		case 'vec2': value = new THREE.Vector2(0.1, 0.1); break;
		    		case 'vec3': value = new THREE.Vector3(0.1, 0.1, 0.1); break;
		    		case 'vec4': value = new THREE.Vector4(0.1, 0.1, 0.1, 0.1); break;
		    		case 'mat3': value = new THREE.Matrix3();
		    		case 'mat4': value = new THREE.Matrix4();
					case 'sampler2D': value = 'undefined'; break;
		    		case 'samplerCube': value = 'undefined'; break;
		    		default: console.log("type is default! : " + type); break;
		    	}
		    	return value;
		    }

		    //배열 납작하게 만들기.
			function flattenDeep(arr1) { return arr1.reduce((acc, val) => Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);	}

		    function CreateCodeMirror()
		    {
		    	//var _Editor = document.getElementById("editor");
			var _Editor = document.getElementById("code-view");

		       	if(_Editor)
		       	{
					_CodeEditor = CodeMirror(_Editor ,
					{
						//value: fragShader,
						lineNumbers: true,
						matchBrackets: true,
						mode: "x-shader/x-fragment",
						keyMap: "sublime",
						autoCloseBrackets: true,
						foldgutter: true,
						gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
						extraKeys: {"Ctrl-Space": "autocomplete"},
						showCursorWhenSelecting: true,
						theme: "monokai",
						indentUnit: 4
					});
					//codeEditor.setSize("100%", "100%");
				}
		    }

		    function TabVertex(isInit)
		    {
		    	console.log('TabVertex');
		    	if(isVertexTab == false)
		    	{ 	
		    	
			    	var codemirrorText = _CodeEditor.getValue();
			    	//console.log('직전 코드에디터 내용 fag : ' + codemirrorText);
			    	if(codemirrorText != "")
			    		_FragmentShaderSource = codemirrorText;
			    }
			    //else
			    	//console.log('이미 버텍스 탭 선택 중.');

		    	_CodeEditor.setValue(_VertexShaderSource); //저장되있던 쉐이더 값을 넣어준다.

		    	if(isInit == true)
		    	{
			    	isVertexTab = true;
			    	isFragTab = false;
			}
			//버튼 색 변경			
			$('#btn-vertex').addClass('active');
			$('#btn-fragment').removeClass('active');
		    }

		    function TabFrag(isInit)
		    {
		    	console.log('TabFrag');
		    	if(isFragTab == false)
		    	{
		    		var codemirrorText = _CodeEditor.getValue();
			    	//console.log('직전 코드에디터 내용 vertex : ' + codemirrorText);
			    	if(codemirrorText != "")
			    	{
			    		_VertexShaderSource = codemirrorText;
			    	}
		    	}
		    	//else
			    	//console.log('이미 프레그 탭 선택 중.');

				_CodeEditor.setValue(_FragmentShaderSource);		

				if(isInit == true)
		    	{
			    	isVertexTab = false;
			    	isFragTab = true;
			}
			//버튼색 변경
			$('#btn-vertex').removeClass('active');
			$('#btn-fragment').addClass('active');

		    }			

			function onAddVertexShader(file)
			{
				var file = this.files[0];				
				var reader = new FileReader();
				reader.addEventListener('load', function(event){					
					SetVertexSource(file.name, event.target.result);
					_GUI.updateDisplay();

				}, false);
				reader.readAsText(event.target.files[0]); 
				event.target.value = '';
			}

			function onAddFragShader(file)
			{
				var file = this.files[0];
				var reader = new FileReader();
				reader.addEventListener('load', function(event){
					SetFragShaderSource(file.name, event.target.result);
					_GUI.updateDisplay();
				}, false);
				reader.readAsText(event.target.files[0]); 
				event.target.value = ''; 
			}

			function SetVertexSource(fileName, soruce)
			{
				guiInfo['vertexShader'] = fileName;
				_VertexShaderSource = soruce;					
				TabVertex(true); 	
			}

			function SetFragShaderSource(fileName, soruce)
			{
				guiInfo['fragmentShader'] = fileName;
				_FragmentShaderSource = soruce;					
				TabFrag(true);	
			}

		    function LightSetting()
		    {
		    	//_Light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				//_Light.position.set( 0, 100, 0 );
				//_Scene.add( _Light );

				_Light = new THREE.DirectionalLight( 0xFFFFFF );
				_Light.position.set( 30, 210, -50 );
				//_Light.castShadow = true;
				//_Light.shadow.camera.top = 180;
				//_Light.shadow.camera.bottom = -100;
				//_Light.shadow.camera.left = -120;
				//_Light.shadow.camera.right = 120;
				_Scene.add( _Light );

				//var helper = new THREE.RectAreaLightHelper( _Light );
				//_Scene.add( helper );
				
				//_Light = new THREE.AmbientLight(0xffffff);//0xff0000
				//_Light.position.set( 0, 10, 10 );
				//_Scene.add( _Light );
		    }

		    function GroundSetting()
		    {
		    	var mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				_Scene.add( mesh );

				var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
				grid.material.opacity = 0.2;
				grid.material.transparent = true;
				_Scene.add( grid );

		    }

		    function OrbitInit()
		    {
		    	//https://threejs.org/docs/#examples/controls/OrbitControls
		    	_Controls = new THREE.OrbitControls( _Camera, _Render.domElement );
		        _Controls.target.set(0, 100, 0);
		        _Controls.update();
		    }		    

		    function RenderInit()
		    {
		    	_Render = new THREE.WebGLRenderer();
		    	_Render.setPixelRatio( window.devicePixelRatio );
		    	_Render.setSize( sceneWidth, sceneHeight );//windopw.innerWidth, window.innerHeight );
		    	_Render.shadowMap.enabled = true;
		    	_Container.appendChild( _Render.domElement);		    	
		    }				   

		    /*function LoadFBX()
		    {
		    	console.log("LoadFBX function!");
		    	
		    	var fbxLoader = new THREE.FBXLoader();
		    	var tempName = 'assets/dona-teodora.fbx';

				fbxLoader.load( tempName, function ( object ) {		

					guiInfo['object'] = tempName;

					var vertexShaderSource = document.getElementById('vertex_shh').textContent;
					var fragmentShaderSource = document.getElementById('fragment_shh').textContent;
					var uniforms = getUniforms(); 			
					
					_GUI.updateDisplay();

					CreateShaderMaterail(uniforms, vertexShaderSource, fragmentShaderSource);

					// FBX loader returns a group containing a multiple sub-objects. Traverse and apply texture to all. 
					object.traverse( function ( child ) {	
						if(child.isMesh)
						{
							//child.castShadow = true;
							//child.receiveShadow = true;
						}
						
						if(child instanceof THREE.Mesh)
						{							
							child.material = _Material;//new THREE.MeshPhongMaterial( { color: Math.random() * 0xffffff } );//_Material;							
							// new THREE.MeshPhongMaterial( { color: Math.random() * 0xffffff } );//
							// THREE.MeshToonMaterial({ color: gray });
						}						
					} );						
					AddSceneObject(object);
				} );
		    }*/	   

		    function AddSceneObject(object)
		    {
		    	RemoveSceneObject();
		    	_ObjectBox = new THREE.BoxHelper(object, 0xffff00);					
				var box3 = new THREE.Box3();
				var size = new THREE.Vector3();

				box3.setFromObject(_ObjectBox);
				box3.getSize(size);

				var fixedHeight = _Camera.position.y / size.y;
				console.log('fixedHeight : ' + fixedHeight);

				var vecScale = new THREE.Vector3( fixedHeight, fixedHeight, fixedHeight );//new THREE.Vector3( 950, 950, 950 );
				object.scale.copy(vecScale);
				object.updateMatrixWorld(true);

				_ObjectBox = new THREE.BoxHelper(object, 0xFF0000);

				_Scene.add(_ObjectBox);
				_Scene.add( object );
				_Object = object;		
		    }

		    function RemoveSceneObject()
		    {
		    	if (typeof _Object != "undefined")
		    		_Scene.remove(_Object);

		    	if (typeof _ObjectBox != "undefined")
		    		_Scene.remove(_ObjectBox);
		    }

		    function RfreshMaterial(uniforms, vertexShaderSource, fragmentShaderSource)
		    {		    	
		    	CreateShaderMaterail(uniforms, vertexShaderSource, fragmentShaderSource);		    	
		    	_Object.traverse(function(child){
		    		if(child instanceof THREE.Mesh)
		    		{
		    			child.material = _Material;
		    			child.material.needsUpdate = true;
		    		}
		    	});		    	
		    	//_Object.materialNeedUpdate= true;
		    	//_Object.uvsNeedUpdate = true;
		    	_Object.needsUpdate = true;
		    	_Object.verticesNeedUpdate = true;
		    	_Object.buffersNeedUpdate = true;

		    	 _Render.render( _Scene, _Camera );		    	
		    }
		    
		    function CreateShaderMaterail(uniforms, vertexShaderSource, fragmentShaderSource)
		    {
				_Material = new THREE.ShaderMaterial({
				  uniforms: uniforms,				  
				  vertexShader: vertexShaderSource,
				  fragmentShader: fragmentShaderSource,
				  transparent: true
				});				
		    }

		    function GetTexture(image) {		    	
	    		return  new THREE.ImageUtils.loadTexture( image.src );		    	
		    }

		    function GetCubeTexture(path0, path1, path2, path3, path4, path5)
		    {
		    	//https://threejs.org/docs/#api/textures/CubeTexture
		    	console.log('cube empty!');
		    	var _loader = new THREE.CubeTextureLoader();
				var urls = [ path0, path1, path2, path3, path4, path5 ];	    	
		    	var textureCube = _loader.load(urls);
		    	return textureCube;
		    }

		   function onWindowResize() 
		   {
				_Camera.aspect = sceneWidth / sceneHeight; //window.innerWidth / window.innerHeight;
				_Camera.updateProjectionMatrix();

				_Render.setSize( sceneWidth, sceneHeight );//( window.innerWidth, window.innerHeight );
			}			

			//Update 같은 개념. 재귀로 속 render해주며 프레임을 그려준다.
			function Animate() 
			{
		        _Render.render( _Scene, _Camera );
				_Stats.update();
				
				requestAnimationFrame( Animate );
			}

			function ResetShaderCompileError()
			{
				document.getElementById("code_vert_error").innerHTML = "";
       			document.getElementById("code_frag_error").innerHTML = "";
			}

			function ResetDatGUI()
			{
				_GUI.destroy();
				_GUI = new dat.GUI( { width: 400});//, load: JSON.parse(json) } );
				InitGUI();
			}

			function ReSetting(vertexShaderSource, fragmentShaderSource)
			{
				setQualifiers(vertexShaderSource, fragmentShaderSource);
				var uniforms = getUniforms();
				RfreshMaterial(uniforms, vertexShaderSource, fragmentShaderSource);
				
				ResetDatGUI();
				generateUI();
			}

			//쉐어더 컴파일
			function onCompile()
			{
				ResetShaderCompileError();
				

				//shaderCanvas.setAttribute("data-fragment", codeEditor.getValue());
				//loadShaders();
				if(typeof _Object == 'undefined')
				{
					alert('_Object is Empty! CreatePanel');
					//return;
					//--------------------------------------------------------------------------------------- TempPlane
					var geometry = new THREE.SphereGeometry( 5, 32, 32 );//new THREE.PlaneGeometry(30, 30, 32);//new THREE.BoxGeometry(10, 10, 10);
					var obj = new THREE.Mesh(geometry, _Material);
					AddSceneObject(obj);
					//---------------------------------------------------------------------------------------
				}

				console.log("Click compile Button");
			
				var vertexShaderSource = _VertexShaderSource;
				var fragmentShaderSource = _FragmentShaderSource;

				if(_CodeEditor.getValue() == "") {					
					vertexShaderSource = document.getElementById('vertex_shh').textContent;
				}
				else {
					if(isVertexTab == true) {
						vertexShaderSource = _CodeEditor.getValue();
					}
				}		


				if(_CodeEditor.getValue() == "") {					
					fragmentShaderSource = document.getElementById('fragment_shh').textContent;
				}
				else {
					if(isFragTab == true) {
						fragmentShaderSource = _CodeEditor.getValue();
					}					
				}
				
				if (vertexShaderSource != "" && fragmentShaderSource != "")
				{					
					ReSetting(vertexShaderSource, fragmentShaderSource);

					for(var i = 0; i < qualifiers.length; ++i)
					{
						var key = qualifiers[i].variableName;	

				        if(qualifiers[i].keyword == 'sampler2D') {
				        	var _tempKey = _GUI.__folders[key].__controllers[0].property;
				        	var _texture =  GetTexture(fileTagBackup[_tempKey]['texture']);
				        	if(typeof _texture != 'undefined') {
				        		if(_Material.uniforms[key].value != _texture) {
				        			_Material.uniforms[key].value = _texture;			        			
				        		}
				        	}
			        	}
			        	else if(qualifiers[i].keyword == 'samplerCube')
			        	{
			        		var _temp0 = GetControllerImageUrl(key, 0);
			        		var _temp1 = GetControllerImageUrl(key, 1);
			        		var _temp2 = GetControllerImageUrl(key, 2);
			        		var _temp3 = GetControllerImageUrl(key, 3);
			        		var _temp4 = GetControllerImageUrl(key, 4);
			        		var _temp5 = GetControllerImageUrl(key, 5);			        		

			        		var _texture = GetCubeTexture(_temp0, _temp1, _temp2, _temp3, _temp4, _temp5);
			        		if(typeof _texture != 'undefined') {
				        		if(_Material.uniforms[key].value != _texture) {
				        			_Material.uniforms[key].value = _texture;			        			
				        		}
				        	}
			        	}
			        }
				}
				else
					alert('Add Shader File First');

				alert('Compile Compelete');
				//_CompileBtn.setAttribute("disabled", "disabled");

				//SetJsonData();
			}

			function GetControllerImageUrl(key, index)
			{
				var _tempKey = _GUI.__folders[key].__controllers[index].property;

	        	var _url =  fileTagBackup[_tempKey]['texture'].src;
	        	return _url;
			}


			 // once everything is loaded, we run our Three.js stuff.
		    function Init() 
		    {   
		    	console.log("init function!");
				var inputUvFile = document.getElementById("textureFile0");
				inputUvFile.addEventListener("change", onAddTexture);

	    		_Container = document.createElement('div');
	    		//document.body.appendChild( _Container);

			$('#scene-view').append(_Container);

	    		  // create a scene, that will hold all our elements such as objects, cameras and lights.
		        _Scene = new THREE.Scene();
		        _Scene.background = new THREE.Color( 0xa0a0a0 );
				//_Scene.fog = new THREE.Fog( 0xa0a0a0, 200, 1000 );

		        // create a camera, which defines where we're looking at.
		        _Camera = new THREE.PerspectiveCamera(45, sceneWidth/sceneHeight, 1, 4000);//(45, window.innerWidth / window.innerHeight, 1, 2000);
		        _Camera.position.set(100, 200, 300);		       

				//--------------------Light
				LightSetting();
				GroundSetting();

				InitGUI();
				$('#dat-view').append($('.dg:not(.main)'));
				//$('#dat-view').append($('.dg')).appendChild($('.dg .main'));
				//$('#dat-view').append($('.dg .main'));

				//LoadFBX();					

				RenderInit();				

				OrbitInit();

				window.addEventListener( 'resize', onWindowResize, false );

				// stats
				_Stats = new Stats();
				_Container.appendChild( _Stats.dom );

 				// render the scene
		       	//_Render.render( _Scene, _Camera );
		       	_VertexShaderSource = "";
		       	_FragmentShaderSource = "";

		       	CreateCodeMirror();
		       	TabVertex();
		    }	
		</script>
